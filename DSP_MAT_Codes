MATLAB PROGRAMS
//QUESTION 1
//Make up a positive number Nx, which is to be the number of elements in a discrete time signal y(n).
//EXPLANATION
//First the value of N is taken from the user. For the values from 1 to N, the discrete time signal y(n) is generated. The number of elements in y(n) which is given by Nx is obtained using the length function.
//MATLAB CODE
clc;
clear all;
close all;
N=input('Enter the value of N');
n=1:1:N;
y(n)=(8*n)+(3*n);
disp(y(n));
Nx=length(y(n));
disp(Nx);
////////////////////////////////////////////////////////////////////////////////////////////////////////////
//QUESTION 2
//Make up a Matlab function called "Signal(n)" which generates the array y as y(n) = Signal(n) for n = 1 to Nx.
//EXPLANATION
//we define a function signal(n) which generates array y with input parameter n. Run the code by initializing the value of Nx and generating y(n) for values from 1 to Nx.
//MATLAB CODE
function y=signal(n)
y=n.^3+n.^2+n+1;
end
//////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//QUESTION 3
//Store the time values x(n) = n in the array x.	
//EXPLANATION
//we define the time values of n which is to be stored in x and initialize x(n)=n to push the time values into the array.
//MATLAB CODE
clc;
clear all;
close all;
n=1:10
x(n)=n;
disp('The time values stored in array x are');
disp(x(n));
//////////////////////////////////////////////////////////////////////////////////////////////////
//QUESTION 4
//Plot y(n) versus x(n) using a Matlab plot function. Use Matlab commands to label the y and x axes.
//EXPLANATION
//First we define the functions x(n) and Y(n). Then plot the graph for y(n) versus x(n) using stem function. Label y and x axes using ylabel and xlabel functions.
//MATLAB CODE
clc;
clear all;
close all;
for n=1:10
    x(n)=1*n;
end
for n=1:10
    y(n)=n^2;
end
stem(x,y);
xlabel('x(n)');
ylabel('y(n)');
title('Sample plot');
/////////////////////////////////////////////////////////////////////////////////////////////////////////
//QUESTION 5
 //Write a function CONV(h,Nh,x,Nx,y,Ny) which convolves causal signals h(n) with x(n), producing y(n). Here each signal starts at n=1 and ends at times, Nx, Nh or Ny. CONV calculates and outputs Ny.
//EXPLANATION
//we define a function CONV with x, Nx, h, Nh as input parameters and y, Ny as output parameters. Two loops are used inside the function to perform convolution. The inner loop computes the value of y(n) by varying the k values from 1 to Nh. The outer loop computes the value of y for different values of n varying between 1 and Ny. Run the code by entering the input values of x, Nx, h and Nh.
//MATLAB CODE
function [y,Ny]=CONV(x,Nx,h,Nh)
Ny=Nx+Nh-1
for n=1:Ny
y(n)=0;
for k=1:Nh
if ((n-k+1)>=1 && (n-k+1)<=Nx)
y(n)=y(n)+h(k)*x(n-k+1);
end
end
end
stem(y);
xlabel('n');
ylabel('y(n)');
title('Convoluted signal y(n)');
end
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//QUESTION 6
//Write a function Signal which can produce and add together a user-chosen number of signals, S, defined as S(w,n)=n.exp(-n/6).cos(w.n) for n between 1 and Nx. Signal S has the user-chosen parameter w. Program Signal should output an array that stores the samples generated by S(w,n).
//EXPLANATION
//First we define a function signal as given  in the figure with input parameters w and n. Create a main program which calls the function signal for n between 1 and Nx ,where Nx is initialized to some  value. Run the program by getting the value of w from the user to get the output array generated by S(w,n).
//MATLAB CODE
//SIGNAL FUNCTION 
function S=signal(w,n)
    S= n*exp(-n/6)*cos(w*n)
end
//MAIN PROGRAM
clear all;
close all;
Nx=10;
w=input('Enter the value of w');
for n=1:Nx
    y=signal(w,n);
    S(n)=y+0;
end
disp('S=');
disp(S);
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//QUESTION 7
//Write a program called DSINE, with user-chosen parameters h, Nh, wc1, and wc2, which designs a bandpass FIR digital filter. The filter has Nh numbers in its unit pulse response, h. The lower and upper cut-off frequencies are wc1, and wc2. The program should output h as an array.
//EXPLANATION
//First we define the equations of the impulse response of ideal bandpass FIR digital filter in the program saved as DSINE.m with Nh,wc1 and wc2 as input parameters and h as output parameter. The value of n ranges from 1 to Nh where Nh is the filter order. The constant M can be expressed as M=Nh/2. By getting the values of Nh, wc1 and wc2 from the user, the output h is obtained.
//MATLAB CODE
clear all;
close all;
Nh=input('Enter the value of Nh');
wc1=input('Enter the value of wc1');
wc2=input('Enter the value of wc2');
M=Nh/2;
for n=1:1:Nh
if n==M
h(n)=(wc2-wc1)/pi;
else
h(n)=(sin(wc2*(n-M))-sin(wc1*(n-M)))/(pi*(n-M));
end
end
disp(h);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//QUESTION 8
//Write a program called AMP, with parameters Am, w, Nm, x, and Nx, which calculates the amplitude response of x as  
//for k=1 to Nm. The program should output arrays Am and w.
//EXPLANATION
//First we define the given equations in the program saved as AMP.m with Nm, Nx and x as input parameters and Am, w as output parameters. By getting the values of Nm, Nx and x from the user, outputs Am and w are obtained.
//MATLAB CODE
clear all;
close all;
Nm=input('Enter the value of Nm');
Nx=input('Enter the value of Nx');
x=input('Enter the value of x');
for k=1:1:Nm
w(k)=pi*(k-1)/(Nm-1);
z=exp(j*w(k));
s=0;
for n=1:1:Nx
    s=s+(x(n)*(z^(n-1)));
end
Am(k)=abs(s);
end
disp('Am=');
disp(Am);
disp('w=');
disp(w);
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
//QUESTION  9
//Do the following
//a) Generate and plot an input signal x(n) = S(.5,n) + S(1.8,n) + S(2.7,n). Let Nx=100. The amplitude spectrum of x should also be plotted, with Nm=100.
//(b) Design a filter h with Nh=65, which passes S(1.8,n) but rejects the other two components of x. Plot h(n) and the amplitude response of h(n). Let Nm=100.
// (c) Calculate the filtered signal y(n)=h(n)*x(n) with program CONV from Program assignment #2. Plot y(n) and its amplitude spectrum, with Nm=100.	
//EXPLANATION
//For part a we write the code to calculate the input signal x(n) as given in the question using  S(w,n) from question 2.  x(n) is generated for n=1 to Nx with Nx=100. plot x(n) versus n to plot the input signal. Using the equations to obtain the amplitude spectrum from question 4, the amplitude spectrum of x is plotted with Nm=100. For part b to design a filter h with Nh=65, using question 3, the cut-off frequencies are assigned such that the filter passes S(1.8,n) but rejects the other two components of x. Plot h(n) and it's amplitude response. For part c the filtered signal is calculated using CONV from program assignment 2 using x(n) and h(n) generated from part a and part b. The calculated signal y(n) is plotted and the amplitude spectrum of y(n) is also plotted.
//MATLAB CODE
clear all;
close all;
%program for part a
Nx=100;
for n=1:Nx
    S1=n*exp(-n/6)*cos(0.5*n);
    S2=n*exp(-n/6)*cos(1.8*n);
    S3=n*exp(-n/6)*cos(2.7*n);
    x(n)=S1+S2+S3;
end
subplot(4,2,1);
stem(x);
xlabel('n');
ylabel('x(n)');
disp('x(n)=');
disp(x);
title('Plot of input signal x(n)');
Nm=100;
for k=1:1:Nm
w(k)=pi*(k-1)/(Nm-1);
z=exp(j*w(k));
Sx=0;
for n=1:1:Nx
    Sx=Sx+(x(n)*(z^(n-1)));
end
Am1(k)=abs(Sx);
end
subplot(4,2,2);
stem(Am1);
xlabel('Frequency w');
ylabel('Am1');
title('plot of amplitude spectrum of x');
%program for part b
Nh=65;
M=Nh/2;
for wc1=0.5:1.8
    for wc2=1.8:2.7
for n=1:1:Nh
if n==M
h(n)=(wc2-wc1)/pi;
else
h(n)=(sin(wc2*(n-M))-sin(wc1*(n-M)))/(pi*(n-M));
end
end
end
end
subplot(4,2,3);
stem(h);
xlabel('n');
ylabel('h(n)');
title('plot of h(n)');
disp('h(n)=');
disp(h);
%program for part c
for k=1:1:Nm
w(k)=pi*(k-1)/(Nm-1);
z=exp(j*w(k));
Sh=0;
for n=1:1:Nh
    Sh=Sh+(h(n)*(z^(n-1)));
end
Am2(k)=abs(Sh);
end
subplot(4,2,4);
stem(Am2);
xlabel('Frequency w');
ylabel('Am2');
title('plot of amplitude spectrum of h(n)');
%program for part d
[y,Ny]=CONV(x,Nx,h,Nh);
disp('y(n)=');
disp(y);
subplot(4,2,5);
stem(y);
xlabel('n');
ylabel('y(n)');
title('plot of y(n)');
for k=1:1:Nm
w(k)=pi*(k-1)/(Nm-1);
z=exp(j*w(k));
Sy=0;
for n=1:1:Ny
    Sy=Sy+(y(n)*(z^(n-1)));
end
Am3(k)=abs(Sy);
end
subplot(4,2,6);
stem(Am3);
xlabel('Frequency w');
ylabel('Am3');
title('plot of amplitude spectrum of y(n)');
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//QUESTION 10
//Write a Matlab function called "RECON" with parameters x, NX, N1, N2, y, and Ny. RECON performs the following operations: (a) It takes the array x and inserts (N1 – 1) zeroes between each pair of adjacent samples, to generate the longer waveform xx, whose last sample is number Nxx. (b) It generates a lowpass filter h(n) = sinc[(n-nd)/N1] for n = 1 to Nh where  N2 , and the time delay nd is (1+Nh)/2 .Nh = 1 + 2 N1 (c) It convolves h(n) with xx(n) to produce y(n). Samples of y(n) are then shifted nd samples to the left, as y(n) = y(n+nd) for n = 1 to Nxx ., so Ny = Nxx + nd.
//EXPLANATION
//We define a function called RECON with x, N1 and N2 as input parameters and y, Ny as output parameters and it performs the following operations. a)A set of codes are defined to insert N1-1 zeroes between a pair of adjacent samples in the input array x so that we get a longer waveform xx(n) b) The given equations are defined in the code to generate a low pass filter h(n). c) By using the CONV function from program assignment 2, xx(n) and h(n) are convolved to get y(n). The convolved output is then shifted by nd samples to the left by using y(n)=y(n+nd).
//PROGRAM CODING
function [y,Ny]=RECON(x,N1,N2)
Nx=length(x)
xx=zeros(1,N1*Nx)
xx([1:N1:length(xx)])=x
Nxx=length(xx)
Nh=1+2*N1*N2
nd=(1+Nh)/2
for n=1:Nh
    h(n)=(sinc(n-nd))/N1
end
disp(h);
Y=CONV(xx,Nxx,h,Nh)
for n=1:Nxx
    y(n)=Y(n+nd)
end
Ny=Nxx+nd
end
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//QUESTION 11
//Write a main program which; (a) Defines and plots the array z with Nz =101, so that z(n) is an approximated bandlimited signal of your choice. Plot the amplitude spectrum of z(n) to confirm that it is approximately bandlimited. (b) Calculates the decimated signal x(n) for N1 = 4 as x(n) = z(1+(n-1) to 25, so Nx = 25. Plots x(n). (c) Reconstructs the missing points of z(n) by calling RECON with N2 = 3, and plots the reconstructed function y(n) on the same time axes as z(n).
//EXPLANATION
//First the array z is defined with length Nz=101, where z(n) is an approximated bandlimited signal. The amplitude spectrum of z(n) is plotted to confirm that z(n) is approximately bandlimited. The decimated signal x(n) is obtained using the expression given in the question for length Nx=25. Then the decimated signal x(n) is plotted. The missing points of z(n) is reconstructed by calling RECON function defined in the question 1 with N2=3. The reconstructed function is given by y(n) and it is plotted on the same time axes as z(n).
//PROGRAM CODING
clear all;
close all;
f=20;
Nz=101;
Nm=101;
for n=1:Nz
    z(n)=sin((2*pi*f*n)+pi);
end
for k=1:1:Nz
w(k)=pi*(k-1)/(Nm-1);
z1=exp(j*w(k));
s=0;	
for n=1:1:Nz
    s=s+(z(n)*(z1^(n-1)));
end
Am(k)=abs(s);
end
subplot(2,2,1);
stem(z);
xlabel('n');
ylabel('z(n)');
title('Plot of z(n)');
subplot(2,2,2);
stem(Am);
xlabel('Frequency w');
ylabel('Am');
title('Amplitude Spectrum of z(n)');
N1=4;
Nx=25;
for n=1:Nx
x(n)=z(1+(n-1)*N1) 
end
subplot(2,2,3);
stem(x);
xlabel('n');
ylabel('x(n)');
title('Decimated signal x(n)');
N2=3;
[y,Ny]=RECON(z,N1,N2)
subplot(2,2,4);
stem(y);
hold on
stem(z);
hold off
title('Reconstructed signal y(n) and original signal z(n)');
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//QUESTION 12
//Turn in computer output, including the listings of the main program and the subprogram RECON, plots of x(n) and the output signal y(n), as well as z(n) and its amplitude spectrum.
//EXPLANATION
//First the array z is defined with length Nz=101, where z(n) is an approximated bandlimited signal. The amplitude spectrum of z(n) is plotted to confirm that z(n) is approximately bandlimited. The decimated signal x(n) is obtained using the expression given in the question for length Nx=25. Then the decimated signal x(n) is plotted. The missing points of z(n) is reconstructed by calling RECON function which is defined with x, N1 and N2 as input parameters and y, Ny as output parameters. A set of codes are defined in the RECON function  such that N1-1 zeroes are inserted between a pair of adjacent samples in the input array and the low pass filter h(n) is generated. The CONV function from program assignment 2 is used to perform convolution operation. The convolved output is then shifted by nd samples to the left which is a reconstructed function given by y(n). y(n) is plotted on the same time axes as z(n).
//PROGRAM CODING
//MAIN PROGRAM
clear all;
close all;
f=20;
Nz=101;
Nm=101;
for n=1:Nz
    z(n)=sin((2*pi*f*n)+pi);
end
for k=1:1:Nz
w(k)=pi*(k-1)/(Nm-1);
z1=exp(j*w(k));
s=0;	
for n=1:1:Nz
    s=s+(z(n)*(z1^(n-1)));
end
Am(k)=abs(s);
end
subplot(2,2,1);
stem(z);
xlabel('n');
ylabel('z(n)');
title('Plot of z(n)');
subplot(2,2,2);
stem(Am);
xlabel('Frequency w');
ylabel('Am');
title('Amplitude Spectrum of z(n)');
N1=4;
Nx=25;
for n=1:Nx
x(n)=z(1+(n-1)*N1) 
end
subplot(2,2,3);
stem(x);
xlabel('n');
ylabel('x(n)');
title('Decimated signal x(n)');
N2=3;
[y,Ny]=RECON(z,N1,N2)
subplot(2,2,4);
stem(y);
hold on
stem(z);
hold off
title('Reconstructed signal y(n) and original signal z(n)');
//SUBPROGRAM RECON
function [y,Ny]=RECON(x,N1,N2)
Nx=length(x)
xx=zeros(1,N1*Nx)
xx([1:N1:length(xx)])=x
Nxx=length(xx)
Nh=1+2*N1*N2
nd=(1+Nh)/2
for n=1:Nh
    h(n)=(sinc(n-nd))/N1
end
disp(h);
Y=CONV(xx,Nxx,h,Nh)
for n=1:Nxx
    y(n)=Y(n+nd)
end
Ny=Nxx+nd
end
//SUBPROGRAM CONV
function [y,Ny]=CONV(x,Nx,h,Nh)
Ny=Nx+Nh-1
for n=1:Ny
y(n)=0;
for k=1:Nh
if ((n-k+1)>=1 && (n-k+1)<=Nx)
y(n)=y(n)+h(k)*x(n-k+1)
end
end
end
end
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//QUESTION 13
//Generate a signal x(n) containing a ramp. Calculate its FFT X(k) and then take the inverse FFT of X(k). Confirm that the result is a ramp.
//EXPLANATION
//First the code is written to generate a ramp signal x(n). The FFT of x(n), X(k) is obtained by using fft function and the inverse FFT of X(k) is obtained by using ifft function. If the result of ifft function is equal to n,  it is confirmed that the result is a ramp.
//PROGRAM CODING
clc;
clear all;
close all;
N=input('Enter the length of the ramp sequence');
N1=input('Enter the N point');
n=1:1:N
x(n)=n;
disp('x(n)=');
disp(x);
xp=[x,zeros(1,N1-N)];
Xk=fft(xp,N1);
disp('FFT of x(n) Xk=');
disp(Xk);
y=ifft(Xk,N);
disp('IFFT of Xk=');
disp(y);
if y==n
    disp('The result is a ramp signal');
end
stem(n,y);
xlabel('n');
ylabel('IFFT of Xk');
title('RESULTANT SIGNAL');
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//QUESTION 14
//Write a function called IMP with parameters h, Nh, w1, and w2. Imp (a) Produces an impulse response h(n) for n between 1 and Nh such that (b) h(n) is bandpass with cut-off frequencies w1 and w2.
//EXPLANATION
//The impulse response of an ideal bandpass filter with cut-off frequencies w1 and w2 is written in the code where the value of the variable n ranges between 1 and Nh, where Nh is the order of the filter. The constant M can be expressed as M=Nh/2. 
//PROGRAM CODING
function [h]=IMP(Nh,w1,w2)
M=Nh/2;
for n=1:Nh
if n==M
h(n)=(w2-w1)/pi;
else
h(n)=(sin(w2*(n-M))-sin(w1*(n-M)))/(pi*(n-M));
end
end
disp('Impulse response of bandpass filter h(n)=')
stem(h)
xlabel('n')
ylabel('h(n)')
title('IMPULSE RESPONSE OF BANDPASS FILTER')
end
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//QUESTION 15
//Write a function called Freq with parameters h, Nh, N, AMP, and w that (a) Calls an FFT of order N for h(n)(b) Stores 1+N/2 points of the magnitude response of h in array AMP (c) Stores 1+N/2 samples w(k) in array w.
//EXPLANATION
//First FFT of order N for h(n) is obtained. Then an array AMP is obtained by storing 1+N/2 points of the magnitude response of h and array w is obtained by storing 1+N/2 samples of w(k).
//PROGRAM CODING
function [AMP,w]=freq(h,N)
Nh=length(h)
xp=[h,zeros(1,N-Nh)]
y1=fft(xp,N)
z=abs(y1)
AMP=z(1:N/2+1)
k=0:1:N-1
wk=(2*pi*k)/N
w=wk(1:N/2+1)
end
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//QUESTION 16
//Write a function called Periodogram, with parameters x, Nx, N, w, and P, that (a) Takes N samples of x(n) and calculates 1+N/2 samples P(k) of its periodogram using an order N FFT. (b) Outputs P(k) and w(k)
//EXPLANATION
//A set of codes are written under the function periodogram to calculate p(k) and w(k) with 1+N/2 samples using an N order FFT. The entire function is saved as periodogram.m
//PROGRAM CODING
function [pk,wk]=periodogram(f0)
n=1:50
x=sin(2*pi*f0*n)+randn(size(n))
N=length(x)
Nx=fft(x)
k=1:N/2+1
Nx=Nx(k)
z=abs(Nx)
pk=(1/N)*z.^2
wk=(2*pi*k)/N
end
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//QUESTION 17
//Write a program that (a) Generates a bandpass FIR filter h(n) and calculates and plots its amplitude response. (b) Generates 2048 samples of white noise with variance 1 and convolves h(n) with x(n) to produce y(n). w1 and w2 are user chosen. (c) Produces z(n) as y(n-512) + sin(won) for n between 1 and 1024. wo is user chosen. (d) Calculates and plots the periodogram of z(n). (e) Using K = 10, calculates and plots the Bartlett estimate of the power spectral density of z(n).
//EXPLANATION
//First a set of codes are written to generate a bandpass FIR filter h(n). Its amplitude response is obtained and plotted using the equations from assignment 2. Then 2048 samples of white noise with variance 1 is generated which is given as x(n). x(n) and h(n) are convolved to produce y(n). z(n) is obtained using the given equation where n varies from 1 to 1024. Periodogram of z(n) is calculated and plotted. Bartlett estimate of the power spectral density of z(n) is calculated and plotted for k=10.
//PROGRAM CODING
clc;
clear all;
close all;
Nh=65;
w1=input('Enter the value of w1');
w2=input('Enter the value of w2');
w0=input('Enter the value of w0');
M1=Nh/2;
for n=1:1:Nh
if n==M1
h(n)=(w2-w1)/pi;
else
h(n)=(sin(w2*(n-M1))-sin(w1*(n-M1)))/(pi*(n-M1));
end
end
subplot(4,2,1);
stem(h);
xlabel('n');
ylabel('h(n)');
title('BANDPASS FIR FILTER h(n)');
Nm=65;
for kx=1:1:Nm
w1(kx)=pi*(kx-1)/(Nm-1);
z1=exp(j*w1(kx));
s=0;
for n=1:1:Nh
    s=s+(h(n)*(z1^(n-1)));
end
Am(kx)=abs(s);
end
subplot(4,2,2);
stem(Am);
xlabel('Frequency w');
ylabel('Am');
title('AMPLITUDE RESPONSE OF h(n)');
xn=wgn(2048,1,0);
subplot(4,2,3)
stem(xn);
xlabel('n');
ylabel('xn');
title('GENERATED PLOT OF SAMPLES OF WHITE NOISE');
Nx=length(xn);
y=conv(xn,h(n));
subplot(4,2,4);
stem(y);
xlabel('n');
ylabel('y(n)');
title('RESULTANT OF CONVOLVED SIGNAL');
for n=1:1024
    if(n-512>0)
    z(n)=y(n-512)+sin(w0*n);
    else
        z(n)=sin(w0*n);
    end
end
subplot(4,2,5);
stem(z);
xlabel('n');
ylabel('z(n)');
title('PLOT OF z(n)');
N=length(z);
N1=fft(z);
k1=1:N/2+1;
N1=N1(k1);
z0=abs(N1);
pk=(1/N)*z0.^2
wk=(2*pi*k1)/N;
subplot(4,2,6);
plot(wk,10*log10(pk));
xlabel('wk');
ylabel('pk');
title('PERIODOGRAM OF z(n)');
fs=100;
px=spectrum.periodogram({'bartlett',10});
subplot(4,2,7);
psd(px,z,'fs',fs);
title('PLOT OF BARTLETTE ESTIMATE OF POWER SPECTRAL DENSITY OF z(n)');
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


 


 








 	
